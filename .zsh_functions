source ~/dev/dotfiles/scripts/__reusable_variables.sh

# Define custom copy function
function copy_and_create_folders() {
    echo "Debug: Function copy_and_create_folders called"  # Debug line
    last_arg="${@: -1}"  # This will get the last argument
    echo "Debug: last_arg=$last_arg"
    echo "Debug: dirname of last_arg=$(dirname "$last_arg")"
    echo "Debug: Checking if $last_arg or $(dirname "$last_arg") exists."
    if [[ ! -d "$last_arg" && ! -d "$(dirname "$last_arg")" ]]; then
      echo "Debug: Inside if condition"
        target_dir="$(dirname "${@[-1]}")"
        mkdir -p "$target_dir"
        echo "Created directory structure: $target_dir"
    fi
    
    # Now use the regular cp command
    command cp "$@"
}

# Paste link form clipboard and create a new pet snippet
function plink ()
{
  link=$(xclip -o -sel clipboard)
  desc="$*"
  if [[ -z $desc ]]; then
   echo "Provide description for link" 
   return 1
  fi

  if [[ -z $link ]]; then
   echo "Provide url to link" 
   return 1
  fi

  if [[ $link =~ ^https?:// ]]; then
    echo "Linking $link"
    command_name="xdg-open \\\"$link\\\""
    description="Link to $desc"
    tag="link"

    # Use expect to interact with pet new
    /usr/bin/expect <<EOF
      spawn pet new -t
      expect "Command>"
      send "${command_name}\r"
      expect "Description>"
      send "${description}\r"
      expect "Tag>"
      send "${tag}\r"
      expect eof
EOF
  else
    echo "Not a valid url"
    return 1
  fi
}

# Restart a tmuxinator session
function mst ()
{
  if [[ -z $1 ]]; then
   echo "Provide tmuxinator session to stop" 
  fi

  tmuxinator stop "$1"
  tmuxinator start poke
}

# dynamic prefix variable using prefix_separator
function testme ()
{
prefix="${1:+$1$prefix_separator}"
echo ${prefix}
}

# Creates a folder named with the current or prefixed date, using the format "prefix-YYYY-MM-DD" if a prefix is provided.
function mkdd ()
{
 mkdir -p ${1:+$1$prefix_separator}$(date +%F); }

# Creates a real-time countdown with alert sound, useful for bash scripts and terminal.
function timer ()
{
  total=$1 
  for ((i=total; i>0; i--)); do sleep 1; printf "Time remaining $i secs \r"; done 
  echo -e "\a" 
}

# Display calendar with day highlighted
function cal ()
{
  if [ -t 1 ] ; then alias cal="ncal -b" ; else alias cal="/usr/bin/cal" ; fi
}

# Simplifies font installation, making font customization easier and improving visual experience in the shell
function install_font ()
{
  if [[ -z $1 ]]; then
   echo provide path to zipped font file 
   return 1
  fi
  
  font_zip=$(realpath "$1")

  unzip "$font_zip" "*.ttf" "*.otf" -d ~/.local/share/fonts/
  fc-cache -vf
}

# Searches for a string in files using rga and fzf in case sensitive mode, and opens the file with nvim.
function fifs() {
    if [ ! "$#" -gt 0 ]; then echo "Need a string to search for!"; return 1; fi
    local file
    file="$(rga --max-count=1 --files-with-matches --no-messages "$*" | fzf-tmux +m --preview="rga --pretty --context 10 '"$*"' {}")"  && echo "opening $file" && nvim "$file" || return 1
}

# Searches for a string in files using rga and fzf, and opens the file with nvim.
function fif() {
    if [ ! "$#" -gt 0 ]; then echo "Need a string to search for!"; return 1; fi
    local file
    file="$(rga --max-count=1 --ignore-case --files-with-matches --no-messages "$*" | fzf-tmux +m --preview="rga --ignore-case --pretty --context 10 '"$*"' {}")" && echo "opening $file" && nvim "$file" || return 1;
}

# Creates a new gist with a unique filename including current date and random number
function gist ()
{
   gh gist create --filename $(echo $(date +"%m-%d-%y")-$RANDOM.sh)
}

# Uploads content to clbin and copies URL to clipboard, opens in browser
function share ()
{
  curl -sF 'clbin=<-' https://clbin.com | xargs -I _ echo -n _"?hl" | tee >(xsel -ib 2>&1) | tee >(xargs echo) | nohup xargs xdg-open >/dev/null 2>&1
}

# Copy file name to clipboard
function copyname() {
    file=$1
    stat -t $1 | cut -d ' ' -f1 | xargs echo -n | xsel -ib
}

# Copy the current working directory path to the clipboard
function cpa() {
    if command -v xclip > /dev/null; then
        printf "%s" "$PWD" | xclip -selection clipboard
        printf "%s\n" "Current working directory ('$(basename "$PWD")') path copied to clipboard."
    else
        printf "%s\n" "Error: 'xclip' command not found. Please install 'xclip' to use this function."
    fi
}

# Change the directory to the path stored in the clipboard
function dpa() {
    if command -v xclip > /dev/null; then
        local target_dir
        target_dir="$(xclip -o -sel clipboard)"
        if [[ -d "${target_dir}" ]]; then
            cd "${target_dir}" && printf "%s\n" "Changed directory to: ${target_dir}"
        else
            printf "%s\n" "Error: Invalid directory path or directory does not exist."
        fi
    else
        printf "%s\n" "Error: 'xclip' command not found. Please install 'xclip' to use this function."
    fi
}

# Add all changes to git, commit with given message, and push
function gac() {
  git add .
  git commit -m "$1"
  git push
}

# Add all changes to git, commit with given message and signed-off-by line, and push
function gacs() {
  git add .
  git commit -m "$1" -s
  git push
}

# Search for my open PRs and open the selected one in a web browser
function ghpr() {
  pr_data=$(gh search prs --author "@me" --state=open --json url,repository,title | \
            jq -r '.[] | select(.title) | "\(.title) | \(.url)"')

  longest=$(echo "$pr_data" | awk -F'|' '{ if (length($1) > max) max = length($1) } END { print max }')

  echo "$pr_data" | awk -v max="$longest" -F'|' '{ printf "%-" max "s | %s\n", $1, $2 }' | \
  fzf | awk -F'|' '{print $2}' | xargs xdg-open > /dev/null 2>&1 
}

# Select gist, preview it, output to terminal and go to web view
function ghgistweb()
{
  GH_FORCE_TTY=100% gh gist list --limit 1000 | fzf --ansi --preview 'GH_FORCE_TTY=100% gh gist view {1}' --preview-window up | awk '{print $1}' | xargs gh gist view --web | tee /dev/tty | xsel --clipboard
}

# Select gist, preview it, output to terminal and copy to clipboard
function ghgist()
{
  GH_FORCE_TTY=100% gh gist list --limit 1000 | fzf --ansi --preview 'GH_FORCE_TTY=100% gh gist view {1}' --preview-window up | awk '{print $1}' | xargs gh gist view --raw | tee /dev/tty | xsel --clipboard
}

# Select any open PR form the active repo and open it in a web browser
function ghprrepo()
{
  GH_FORCE_TTY=100% gh pr list | fzf --ansi --preview 'GH_FORCE_TTY=100% gh pr view {1}' --preview-window up --header-lines 3 | awk '{print $1}' | xargs gh pr diff -w
}

# Find a repo for authenticated user with gh CLI and cd into it, clone and cd if not found on disk
function repo() {
  export repo=$(fd . ${HOME}/dev --type=directory --max-depth=1 --color always| awk -F "/" '{print $5}' | fzf --ansi --preview 'onefetch /home/decoder/dev/{1}' --preview-window up)
    if [[ -z "$repo" ]]; then
        echo "Repository not found"
      else
        echo "Repository found locally, entering"
        cd ${HOME}/dev/$repo
        if [[ -d .git ]]; then
          echo "Fetching origin"
          git fetch origin
          onefetch
        fi
          create_tmux_session "${HOME}/dev/$repo"
    fi
}

# Create a new tmux session with the given path in the dev folder
function create_tmux_session() {
    local RESULT="$1"
    zoxide add "$RESULT" &>/dev/null # add to zoxide database
    local FOLDER=$(basename "$RESULT")
    local SESSION_NAME=$(echo "$FOLDER" | tr ' ' '_' | tr '.' '_' | tr ':' '_')

    if [ -d "$RESULT/.git" ]; then
        local GIT_BRANCH=$(git -C "$RESULT" symbolic-ref --short HEAD 2>/dev/null)
        SESSION_NAME="$SESSION_NAME-$GIT_BRANCH"
    fi

    if tmux list-sessions -F '#S' | grep -q "^$SESSION_NAME$"; then
        SESSION="$SESSION_NAME"
    else
        SESSION=""
    fi

    if [ -z "$TMUX" ]; then                            # not currently in tmux
        if [ -z "$SESSION" ]; then                        # session does not exist
            tmux new-session -s "$SESSION_NAME" -c "$RESULT" # create session and attach
        else                                              # session exists
            tmux attach -t "$SESSION"                        # attach to session
        fi
    else                                                  # currently in tmux
        if [ -z "$SESSION" ]; then                           # session does not exist
            tmux new-session -d -s "$SESSION_NAME" -c "$RESULT" # create session
            tmux switch-client -t "$SESSION_NAME"               # attach to session
        else                                                 # session exists
            tmux switch-client -t "$SESSION"                    # switch to session
        fi
    fi
}

# Adjust system volume to given percentage or display current volume
function vol() {
    echo "Usage: provide volume in intiger, e.g. 50 will adjust vol to 50%"
    if [[ -z "$1" ]]; then
        amixer get Master
        return
    fi
    amixer set Master "$1"%
    echo "Volume set to $1%"
}

# Switch primary monitor between HDMI and DVI-D-0
function mon ()
{
  active_mon=$(xrandr | grep primary)

  if [[ "$active_mon" =~ "HDMI" ]]; then
    xrandr --output DVI-D-0 --primary
  else
    xrandr --output HDMI-0 --primary
  fi
}

# Toggle audio output between main monitor and headset
function sout() {
  echo "Usage: sout toggles between\n - hdmi: plays sound via main monitor or\n - head: plays sound via main headset\n"

  # Do some grep magic to retrieve id of output devices, * indicates active device
  local local_output=$(wpctl status | grep Sinks: -A2 | head -3 | grep \* | grep "\d+" -Po | head -1)
  local new_output=$(wpctl status | grep Sinks: -A2 | head -3 | grep -v \* | grep "\d+" -Po | head -1)

  # Swap the the device with no star making it active and adding the star
  wpctl set-default "$new_output"
  local sink_name=$(wpctl status | grep Sinks: -A2 | head -3 | grep \*)

  if [[ $(echo "$sink_name" |  grep "GP106 High Definition") ]]; then
    wpctl set-mute $(wpctl status | grep --after-context=3 " ├─ Sources:" | grep "Microphone Mono" | grep "\d+" -Po | head -n 1) 1
    amixer set Master 50%
    local_output='hdmi'
    echo "Sound local_output set to '$=monitor, mic muted\nVolume 50%"
  else
    amixer set Master 100%
    local_output='head'
    echo "Sound local_output set to 31=headset\nVolume 100%"
  fi
} 

# Start multiple tmuxinator sessions
function msm ()
{
  if [[ -z $1 ]]; then
    echo "Provide one or more tmuxinator sessions to start"
    return 1  # Exit early with error status
  fi

  # Split the arguments into an array, zsh populates this by default
  for session in "$@"; do
    tmuxinator start "$session"
  done
}

# Close multiple tmuxinator sessions
function mst ()
{
  if [[ -z $1 ]]; then
    echo "Provide one or more tmuxinator sessions to start"
    return 1  # Exit early with error status
  fi

  # Split the arguments into an array, zsh populates this by default
  for session in "$@"; do
    tmuxinator stop "$session"
  done
}

# Check system info using onefetch and output in terminal
function checkfetch() {
    local res=$(onefetch) &> /dev/null
    if [[ "$res" =~ "Error" ]]; then
        echo ""
    else echo $(onefetch)
    fi
}

# Display list of shortcuts in color using less
function key() {
  bat --color=always ${HOME}/shortcuts.md | less -i -R
}

# Open a debugging shell within a Kubernetes pod
function kcdebug() {
  kubectl run -i --rm --tty debug --image=busybox --restart=Never -- sh
}

# Create a directory and change to it in one command
function mkd() {
  mkdir -p "$@" && cd "$_";
}
function ghprview ()
{
    if [ -z "$1" ]; then
        echo "Provide link to pr" 
        return
    else 
      local pr="$1"
      local repo=$(echo "$pr" | cut -d "/" -f5)
      local pr_nr=$(echo "$pr" | cut -d "/" -f7)
      gh pr view -R "upbound/$repo" "$pr_nr" --web
    fi  
}

